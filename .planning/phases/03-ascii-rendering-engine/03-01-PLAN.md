---
phase: 03-ascii-rendering-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - js/config.js
  - js/analyzer.js
  - js/renderer.js
  - index.html
  - css/style.css
  - eslint.config.js
autonomous: true

must_haves:
  truths:
    - 'Live webcam feed displays as ASCII characters on screen'
    - 'ASCII characters map to pixel brightness using perceptual luminance'
    - 'ASCII output displays green text on black background'
    - 'ASCII output fills available viewport with auto-sized monospace font'
  artifacts:
    - path: 'js/config.js'
      provides: 'Character set definitions (standard, dense, minimal)'
      contains: 'characterSets'
    - path: 'js/analyzer.js'
      provides: 'Pixel sampling grid and brightness-to-character conversion'
      exports: ['sampleVideoToAscii']
    - path: 'js/renderer.js'
      provides: 'ASCII rendering in draw loop with pre element updates'
      contains: 'textContent'
    - path: 'index.html'
      provides: 'ASCII output pre element'
      contains: 'ascii-output'
    - path: 'css/style.css'
      provides: 'Green-on-black terminal styling for ASCII output'
      contains: '#ascii-output'
  key_links:
    - from: 'js/renderer.js'
      to: 'js/analyzer.js'
      via: 'sampleVideoToAscii() call in draw loop'
      pattern: 'sampleVideoToAscii'
    - from: 'js/renderer.js'
      to: 'index.html #ascii-output'
      via: 'textContent update'
      pattern: 'textContent'
    - from: 'js/analyzer.js'
      to: 'js/config.js'
      via: 'character set import'
      pattern: 'characterSets'
---

<objective>
Build the core ASCII rendering pipeline: pixel sampling, brightness-to-character conversion, and green-on-black terminal display.

Purpose: This is the heart of the app — converting live webcam video into ASCII art at real-time frame rates. Without this, there's nothing to show.
Output: Live ASCII art rendering from webcam feed displayed in a viewport-filling green-on-black pre element.
</objective>

<execution_context>
@/Users/beausterling/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beausterling/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-ascii-rendering-engine/03-CONTEXT.md
@.planning/phases/03-ascii-rendering-engine/03-RESEARCH.md
@.planning/phases/02-webcam-capture/02-02-SUMMARY.md
@js/config.js
@js/analyzer.js
@js/renderer.js
@js/webcam.js
@index.html
@css/style.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Character sets in config.js and pixel sampling engine in analyzer.js</name>
  <files>js/config.js, js/analyzer.js</files>
  <action>
**js/config.js** — Replace the existing placeholder charSet and resolution with a proper configuration object:

1. Add `characterSets` object with 3 character sets. Each set is a string ordered from darkest (space) to brightest (densest character). Bright pixels = dense characters per user decision ("drawing with light"). Each set should feel visually distinct:
   - `standard`: ~12 characters, good all-around tonal range (e.g., ` .:-=+*#%@`)
   - `dense`: ~16+ characters, maximum tonal gradation with many symbol weights (e.g., ` .'"\`:;I!i><~+\_-?][}{1)(|\/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao\*#MW&8%B@$`)
   - `minimal`: ~5-6 characters, bold graphic look with fewer tones (e.g., ` .+#@`)

2. Add `ascii` config section:
   - `defaultColumns`: 80
   - `minColumns`: 40
   - `maxColumns`: 160
   - `defaultCharSet`: 'standard'
   - `aspectRatioCorrection`: 0.55 (monospace chars are ~2:1 tall:wide, so row height = cellWidth \* 0.55 to correct; tune this value based on what looks right with monospace font)

3. Keep existing `theme` object (background: '#000000', text: '#00ff00').

4. Remove the old `charSet` and `resolution` properties (they are placeholders from Phase 1 that will be replaced by the new structure).

**js/analyzer.js** — Replace the placeholder `analyze()` function with a real pixel sampling engine:

1. Import `characterSets` from config.js (and the `config` object for ascii settings).

2. Create an offscreen canvas + context at module level for pixel sampling. Set `willReadFrequently: true` on the 2D context for performance (this hints the browser to keep pixel data in CPU memory). Size: 320x240 initially, resize as needed.

3. Export `sampleVideoToAscii(videoElement, cols, charSetName)` function:
   - Draw video frame to offscreen canvas: `ctx.drawImage(videoElement, 0, 0, offCanvas.width, offCanvas.height)`
   - Calculate grid: `cellWidth = offCanvas.width / cols`, `cellHeight = cellWidth * config.ascii.aspectRatioCorrection` (NOT cellWidth \* 2 — use the config value). Compute `rows = Math.floor(offCanvas.height / cellHeight)`.
   - Get ALL pixel data in one call: `ctx.getImageData(0, 0, offCanvas.width, offCanvas.height)` — do NOT call getImageData per-cell (catastrophic for performance).
   - Look up the character set string from `characterSets[charSetName]`. Fall back to `characterSets.standard` if not found.
   - For each grid cell (row, col): sample the center pixel coordinates, calculate index into the ImageData array `((y * offCanvas.width) + x) * 4`, extract R/G/B, compute perceptual luminance: `(0.299 * r) + (0.587 * g) + (0.114 * b)`, map brightness 0-255 to character index: `Math.floor((brightness / 255) * (charSet.length - 1))`, append character to row string.
   - Join rows with newline, return the full ASCII string.

4. Remove the old placeholder `analyze()` export. The new export is `sampleVideoToAscii`.

**Important performance notes for the action section:**

- Single `getImageData()` call for the entire offscreen canvas, then index into the data array per cell — do NOT call getImageData per pixel.
- Resize offscreen canvas only when video dimensions change (check videoWidth/videoHeight against canvas dimensions).
- Keep the offscreen canvas and context as module-level variables (created once, reused every frame).
  </action>
  <verify>

1. `npm run lint` passes with no new errors (warnings OK)
2. `npm run format:check` passes
3. config.js exports `characterSets` object with 3 sets (standard, dense, minimal) and `ascii` config section
4. analyzer.js exports `sampleVideoToAscii` function
5. Manually verify: `characterSets.standard` is a string with ~10-12 chars, `characterSets.dense` has 16+ chars, `characterSets.minimal` has 5-6 chars
6. Each character set starts with space (darkest) and ends with a dense character (brightest)
   </verify>
   <done>
   config.js has 3 distinct character sets and ASCII configuration. analyzer.js has a performant pixel sampling engine that converts a video element + column count into an ASCII string using perceptual luminance mapping.
   </done>
   </task>

<task type="auto">
  <name>Task 2: ASCII display element, green terminal styling, and renderer integration</name>
  <files>index.html, css/style.css, js/renderer.js, eslint.config.js</files>
  <action>
**index.html** — Add the ASCII output element:

1. Add a `<pre id="ascii-output"></pre>` element inside `#canvas-container` (or just after it, adjacent). This pre element will hold the ASCII art text. Place it so it visually occupies the same area as the canvas — the toggle (Plan 02) will show one or the other.

2. The p5.js canvas (created in renderer.js setup) already exists inside `#canvas-container`. The ASCII output pre element should be a sibling or in the same container area.

**css/style.css** — Add terminal-aesthetic ASCII output styling:

1. `#ascii-output`:
   - `font-family: 'Courier New', Courier, monospace` (monospace required for grid alignment)
   - `color: #00ff00` (classic phosphor green per user decision)
   - `background-color: #000000` (black background)
   - `white-space: pre` (preserve spaces and newlines for ASCII grid)
   - `line-height: 1` (tight line spacing so characters form a cohesive image)
   - `letter-spacing: 0` (no extra space between characters)
   - `margin: 0 auto` (center the block)
   - `overflow: hidden` (don't show scrollbars)
   - `text-align: center` (center the pre block content)
   - `padding: 0`
   - The font-size will be calculated dynamically in renderer.js to fill the viewport

2. Update `.canvas-container` min-height to accommodate the ASCII output.

**js/renderer.js** — Integrate ASCII rendering into the p5.js draw loop:

1. Import `sampleVideoToAscii` from `./analyzer.js` and the new config from `./config.js`.

2. Add module-level state:
   - `let asciiMode = true;` (start in ASCII mode — the whole point of the app)
   - `let currentColumns = config.ascii.defaultColumns;` (80)
   - `let currentCharSet = config.ascii.defaultCharSet;` ('standard')
   - `let asciiOutputEl = null;` (cached DOM reference)

3. In `window.setup()`:
   - Cache `asciiOutputEl = document.getElementById('ascii-output')`
   - Hide the p5 canvas initially (since we start in ASCII mode): set `canvas.style.display = 'none'` or `canvas.hide()` — use the p5 canvas reference returned by `createCanvas()`.

4. In `window.draw()`:
   - If `isPaused` or `!isCameraReady()`, return early (same as before).
   - Get `capture` from `getCapture()`.
   - If `asciiMode`:
     - Call `sampleVideoToAscii(capture, currentColumns, currentCharSet)` to get ASCII string.
     - Update `asciiOutputEl.textContent = asciiText`.
     - Calculate and set font size to fill viewport: compute the number of character columns in the output, measure the available width (e.g., `window.innerWidth` or container width), and set `fontSize = availableWidth / currentColumns`. Apply `asciiOutputEl.style.fontSize = fontSize + 'px'`. This makes the ASCII art fill the screen width.
   - If NOT asciiMode (raw video):
     - Draw video to canvas via `drawingContext.drawImage()` (existing code).
     - Keep the auto-resize canvas logic.

5. Export setter functions for Plan 02 to call:
   - `export function setAsciiMode(enabled)` — sets `asciiMode`, toggles canvas display vs ascii-output display
   - `export function setColumns(cols)` — sets `currentColumns`
   - `export function setCharSet(name)` — sets `currentCharSet`

6. In `setAsciiMode(enabled)`:
   - When switching to ASCII mode: hide p5 canvas (`canvas.style.display = 'none'`), show `#ascii-output` (`asciiOutputEl.style.display = 'block'`)
   - When switching to video mode: show p5 canvas (`canvas.style.display = 'block'`), hide `#ascii-output` (`asciiOutputEl.style.display = 'none'`)

**eslint.config.js** — Add any new p5.js globals used (likely none needed beyond what's already there, but check if `windowWidth` or similar is used).

**Performance note:** The font-size calculation in draw() should be guarded so it only recalculates when columns change (cache the last value). Don't recalculate every frame unnecessarily.
</action>
<verify>

1. `npm run lint` passes with no new errors
2. `npm run format:check` passes
3. Open index.html in browser, click Start Camera — live ASCII art appears in green on black
4. ASCII art fills the viewport width with auto-sized font
5. Characters visually correspond to brightness (bright areas = dense characters, dark = spaces)
6. `renderer.js` exports `setAsciiMode`, `setColumns`, `setCharSet`
7. `#ascii-output` element exists in index.html with proper styling
   </verify>
   <done>
   Live webcam feed renders as green ASCII art on black background. ASCII output fills the viewport width with dynamically sized monospace font. The renderer exposes setter functions for mode toggle, column count, and character set (wired in Plan 02).
   </done>
   </task>

</tasks>

<verification>
1. Open the app in a browser, click Start Camera
2. Live webcam feed should appear as ASCII art (green characters on black background)
3. ASCII art should fill the screen width with appropriately sized monospace font
4. Bright areas of the video should show dense characters (@, #, etc.), dark areas show spaces
5. The ASCII rendering should update smoothly (visual check — no visible lag/stutter)
6. `npm run lint` and `npm run format:check` pass
</verification>

<success_criteria>

- Live webcam video converts to ASCII art displayed on screen
- Perceptual luminance formula (0.299R + 0.587G + 0.114B) drives character mapping
- Green-on-black terminal aesthetic (#00FF00 on #000000)
- ASCII output auto-sizes to fill viewport width
- 3 character sets defined in config (standard, dense, minimal)
- Renderer exports setAsciiMode, setColumns, setCharSet for Plan 02 wiring
  </success_criteria>

<output>
After completion, create `.planning/phases/03-ascii-rendering-engine/03-01-SUMMARY.md`
</output>
