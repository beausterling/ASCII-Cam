---
phase: 02-webcam-capture
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - js/renderer.js
  - js/main.js
autonomous: false

must_haves:
  truths:
    - "Clicking Start Camera shows live webcam feed on the p5.js canvas"
    - "Processing pauses automatically when browser tab is hidden"
    - "Processing resumes when browser tab becomes visible again"
    - "Switch Camera button appears and toggles between front/rear cameras"
    - "Error messages display in the error area when camera fails"
    - "Status messages update during camera initialization"
  artifacts:
    - path: "js/renderer.js"
      provides: "p5.js sketch with draw loop rendering webcam to canvas, visibility pause"
      exports: ["initRenderer"]
      min_lines: 40
    - path: "js/main.js"
      provides: "Button click handlers, webcam-renderer wiring, module orchestration"
      min_lines: 40
  key_links:
    - from: "js/main.js"
      to: "js/webcam.js"
      via: "import and button click handlers calling initCamera/switchCamera"
      pattern: "import.*webcam"
    - from: "js/main.js"
      to: "js/renderer.js"
      via: "import and initRenderer call after camera ready"
      pattern: "initRenderer"
    - from: "js/renderer.js"
      to: "js/webcam.js"
      via: "getCapture() in draw loop to render webcam frame"
      pattern: "getCapture"
    - from: "js/renderer.js"
      to: "document.hidden"
      via: "visibilitychange event listener pausing draw loop"
      pattern: "visibilitychange"
---

<objective>
Wire the p5.js sketch to render the live webcam feed on canvas, add visibility pause/resume, and connect all button handlers in main.js to create a working end-to-end camera experience.

Purpose: This plan makes the camera actually work -- users click Start Camera, see live video on canvas, can switch cameras, and battery is preserved when the tab is hidden.

Output: Updated js/renderer.js with p5.js sketch, updated js/main.js with event wiring.
</objective>

<execution_context>
@/Users/beausterling/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beausterling/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-webcam-capture/02-RESEARCH.md
@.planning/phases/02-webcam-capture/02-01-SUMMARY.md
@js/webcam.js
@js/config.js
@index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement p5.js sketch in renderer.js with visibility pause</name>
  <files>js/renderer.js</files>
  <action>
Replace the placeholder renderer.js with a real p5.js sketch module. This is a vanilla JS static site -- p5.js is loaded globally via CDN, so p5 functions (createCanvas, image, background, etc.) are available as globals.

IMPORTANT: p5.js in global mode uses global functions `setup()` and `draw()`. Since we need lazy camera initialization (not on page load), the approach is:

**initRenderer():**
- This function is called from main.js AFTER camera is ready
- It defines the global `setup` and `draw` functions that p5.js will use
- But actually, p5.js auto-calls setup() on load. Since we're using ES modules loaded after p5.js, we need to handle this carefully.

**Correct approach for p5.js global mode with lazy camera:**
- Define `window.setup` to create the canvas and place it in #canvas-container. Canvas size: 320x240 (matching capture resolution). Use `let canvas = createCanvas(320, 240); canvas.parent('canvas-container');`
- Set background to black initially: `background(0);`
- Define `window.draw` to:
  1. Check `isPaused` flag -- if true, return immediately (skip all processing)
  2. Import/call `isCameraReady()` and `getCapture()` from webcam.js -- if camera not ready, just show black background
  3. If camera ready, call `image(capture, 0, 0, width, height)` to render webcam frame to canvas
- `initRenderer()` export just sets a flag that the renderer is initialized (the setup/draw are already defined at module level)

Wait -- there's a subtlety. p5.js in global mode calls setup() automatically. We need setup() to exist when p5.js runs. Since our script is `type="module"`, it loads after p5.js. We need to define window.setup and window.draw at the module's top level (not inside initRenderer).

**Revised approach:**

At module level in renderer.js:
1. Import `getCapture`, `isCameraReady` from `./webcam.js`
2. Import `config` from `./config.js`
3. Define module-level `isPaused = false`
4. Define `window.setup = function() { ... }` -- creates canvas 320x240, parents to #canvas-container, sets background black
5. Define `window.draw = function() { ... }` -- checks isPaused, checks isCameraReady, renders capture to canvas
6. Add `document.addEventListener("visibilitychange", ...)` that sets `isPaused = document.hidden` and pauses/resumes the capture video element

Export `initRenderer` as a no-op or minimal function (since setup/draw are auto-invoked). Actually, `initRenderer` can be used to configure canvas size or other settings if needed. For now it can just log that renderer is active.

**Visibility pause logic (CAM-03):**
```
document.addEventListener("visibilitychange", () => {
  isPaused = document.hidden;
  const capture = getCapture();
  if (capture && capture.elt) {
    if (document.hidden) {
      capture.elt.pause();
      noLoop(); // Stop p5 draw loop
    } else {
      capture.elt.play();
      loop(); // Resume p5 draw loop
    }
  }
});
```

Use `noLoop()` and `loop()` (p5.js globals) to fully pause/resume the draw cycle for maximum battery savings.

**draw() function:**
```
window.draw = function() {
  background(0); // Black background each frame
  if (!isCameraReady()) return;
  const capture = getCapture();
  if (capture) {
    image(capture, 0, 0, width, height);
  }
};
```

Include student-voice comments explaining:
- Why we use noLoop()/loop() for visibility (battery savings)
- What window.setup and window.draw do in p5.js global mode
- Why we check isCameraReady() before rendering
- Why background(0) clears to black each frame
  </action>
  <verify>
- `grep "window.setup" js/renderer.js` confirms setup is defined
- `grep "window.draw" js/renderer.js` confirms draw is defined
- `grep "visibilitychange" js/renderer.js` confirms visibility API listener
- `grep "noLoop" js/renderer.js` confirms draw loop pausing
- `grep "getCapture" js/renderer.js` confirms webcam integration
- `grep "createCanvas" js/renderer.js` confirms canvas creation
- `npm run lint` passes (warnings OK)
  </verify>
  <done>
renderer.js defines p5.js setup() creating 320x240 canvas in #canvas-container and draw() rendering webcam feed. Visibility API listener pauses/resumes both capture video and p5 draw loop. Camera state checked each frame via isCameraReady()/getCapture().
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire button handlers and module integration in main.js</name>
  <files>js/main.js</files>
  <action>
Update main.js to import webcam module functions and wire the UI button click handlers. Keep the existing figlet logo code intact.

**Imports to add:**
```javascript
import { initCamera, switchCamera, stopCamera } from './webcam.js';
import { initRenderer } from './renderer.js'; // Already imported, keep it
```

Remove the `import { analyze } from './analyzer.js';` line for now -- analyzer is not used in Phase 2 (it's a Phase 3 concern). Actually, keep it to avoid breaking the module structure. It's a placeholder import.

**Inside the DOMContentLoaded handler, after the figlet logo code, add:**

1. Get references to UI elements:
   ```javascript
   const startBtn = document.getElementById('btn-start-camera');
   const switchBtn = document.getElementById('btn-switch-camera');
   const statusEl = document.getElementById('camera-status');
   const errorEl = document.getElementById('camera-error');
   ```

2. Helper functions for UI updates:
   - `showStatus(msg)`: Sets statusEl.textContent = msg, shows statusEl
   - `showError(msg)`: Sets errorEl.textContent = msg, shows errorEl (display block), hides statusEl
   - `clearError()`: Hides errorEl (display none)

3. Start Camera button handler:
   ```javascript
   startBtn.addEventListener('click', async () => {
     clearError();
     showStatus('Initializing camera...');
     startBtn.disabled = true;

     const result = await initCamera();

     if (result.success) {
       showStatus('Camera active');
       startBtn.textContent = 'Camera Running';
       startBtn.classList.replace('btn-success', 'btn-secondary');
       // Show switch camera button on mobile (check for touch support as heuristic)
       if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
         switchBtn.style.display = 'inline-block';
       }
     } else {
       showError(result.error);
       showStatus('');
       startBtn.disabled = false;
     }
   });
   ```

4. Switch Camera button handler:
   ```javascript
   switchBtn.addEventListener('click', async () => {
     clearError();
     showStatus('Switching camera...');
     switchBtn.disabled = true;

     const result = await switchCamera();

     if (result.success) {
       showStatus('Camera active');
     } else {
       showError(result.error);
     }
     switchBtn.disabled = false;
   });
   ```

5. Remove or update the "Future phases will call initRenderer() here" comment. The renderer initializes itself via p5.js auto-setup, so no explicit call needed. Keep the initRenderer import for future configuration use.

**Important:** The initCamera() function in webcam.js must return a Promise (async). Verify the webcam.js contract: initCamera returns `{ success: boolean, error: string|null }`.

Include student-voice comments explaining:
- Why we disable buttons during async operations (prevent double-clicks)
- How the touch detection heuristic works for showing the switch button
- Why we use async/await for camera operations
- The flow: button click -> init camera -> update UI based on result

Run `npm run format` after changes.
  </action>
  <verify>
- `grep "import.*webcam" js/main.js` confirms webcam module imported
- `grep "addEventListener.*click" js/main.js` confirms button handlers
- `grep "initCamera" js/main.js` confirms camera initialization wired
- `grep "switchCamera" js/main.js` confirms camera switching wired
- `grep "showError\|showStatus" js/main.js` confirms UI feedback functions
- `npm run lint` passes (warnings OK)
- `npm run format:check` passes
  </verify>
  <done>
main.js imports webcam module, wires Start Camera and Switch Camera button handlers with async/await, updates status/error UI elements, disables buttons during operations, and shows switch button on mobile devices via touch detection.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete webcam capture system in browser</name>
  <files>index.html</files>
  <action>
Human verification checkpoint. No code changes needed -- verify the complete webcam capture system works end-to-end in a browser. Start the local dev server and test all camera functionality including permissions, error handling, camera switching, and tab visibility pause.
  </action>
  <verify>
1. Start local dev server: `npm run dev` (or `python3 -m http.server 8000`)
2. Open http://localhost:8000 in browser
3. Verify: ASCII CAM figlet logo shows at top, "Start Camera" green button below it
4. Click "Start Camera" -- browser should prompt for camera permission
5. Grant permission -- button should change to "Camera Running" (gray), live webcam feed appears on canvas below
6. (Mobile only) "Switch Camera" button should appear. Tap it to toggle front/rear camera
7. Test error: Open in a private window, click Start Camera, DENY permission -- error message should appear in red
8. Test tab pause: With camera running, switch to another tab for 5 seconds, switch back -- video should pause and resume (check console for no errors)
  </verify>
  <done>Human confirms: camera starts, video renders on canvas, errors display properly, tab pause works. Type "approved" or describe issues.</done>
</task>

</tasks>

<verification>
1. Live webcam feed renders on 320x240 p5.js canvas after clicking Start Camera
2. Permission denied shows user-friendly error message
3. Switch Camera button appears on mobile and toggles cameras
4. Tab hidden pauses both video element and p5 draw loop
5. Tab visible resumes both video and draw loop
6. `npm run lint` passes
7. `npm run format:check` passes
8. No new CDN dependencies added
</verification>

<success_criteria>
- User clicks Start Camera and sees live webcam feed on canvas (CAM-01, CAM-02)
- Permission denied or missing camera shows helpful error message (CAM-01)
- Video captures at 320x240 ideal resolution (CAM-02)
- Processing pauses when tab hidden, resumes when visible (CAM-03)
- Switch Camera button toggles front/rear cameras on mobile with proper stream cleanup (CAM-04)
- All requirements CAM-01 through CAM-04 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/02-webcam-capture/02-02-SUMMARY.md`
</output>
